(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.pick = factory());
}(this, (function () { 'use strict';

	const has = (obj, path) => obj != null && hasOwnProperty.call(obj, path);

	const isString = obj => toString.call(obj) === '[object String]';

	var isArrayLike = val => {
		if (Array.isArray(val)) {
			return true;
		}

		if (!val) {
			return false;
		}

		if (isString(val)) {
			return false;
		}

		if (typeof val !== 'object') {
			return false;
		}

		if (val.nodeType === 1) {
			return !!val.length;
		}

		if (val.length === 0) {
			return true;
		}

		if (val.length > 0) {
			return has(0, val) && has(val.length - 1, val);
		}

		return false;
	};

	const isArguments = obj => toString.call(obj) === '[object Arguments]';

	const flatten = (input, shallow, strict, output = []) => {
		let idx = output.length;
		input.forEach(value => {
			if (isArrayLike(value) && (Array.isArray(value) || isArguments(value))) {
				if (shallow) {
					let j = 0;
					const len = value.length;
					while (j < len) output[idx++] = value[j++];
				} else {
					flatten(value, shallow, strict, output);
					idx = output.length;
				}
			} else if (!strict) {
				output[idx++] = value;
			}
		});
		return output;
	};

	var flatUtil = (array, shallow) => flatten(array, shallow, false);

	const isFunction = obj => toString.call(obj) === '[object Function]';

	const optimizeCb = (func, context, argCount) => {
		if (context === void 0) return func;
		switch (argCount == null ? 3 : argCount) {
			case 1: return value => func.call(context, value);
				// The 2-argument case is omitted because weâ€™re not using it.
			case 3: return (value, index, collection) => func.call(context, value, index, collection);
			case 4: return (accumulator, value, index, collection) => func.call(context, accumulator, value, index, collection);
		}

		return (...args) => func.apply(context, args);
	};

	const isObject = obj => {
		const type = typeof obj;

		return type === 'function' || type === 'object' && !!obj;
	};

	const allKeys = obj => {
		if (!isObject(obj)) return [];
		const keys = [];

		for (const key in obj) keys.push(key);

		return keys;
	};

	const keyInObj = (value, key, obj) => key in obj;

	var pickUtil = (obj, ...keys) => {
		const result = {};
		let [iteratee] = keys;

		if (!obj) {
			return result;
		}

		if (isFunction(iteratee)) {
			if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
			keys = allKeys(obj);
		} else {
			iteratee = keyInObj;
			keys = flatUtil(keys);
			obj = Object(obj);
		}

		keys.forEach(key => {
			const value = obj[key];

			if (iteratee(value, key, obj)) {
				result[key] = value;
			}
		});

		return result;
	};

	return pickUtil;

})));
